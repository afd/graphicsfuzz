"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2019 The GraphicsFuzz Project Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""
import builtins
import collections.abc
import gfauto.common_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import sys

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class ArtifactMetadata(google.protobuf.message.Message):
    """An artifact is a directory containing an ArtifactMetadata proto stored in "artifact.json" and/or a Recipe proto
    stored in "recipe.json", plus any other files and directories within. The recipe can be executed to produce the files
    that make up the artifact, which must include the "artifact.json" file. An artifact is referred to via an
    "artifact path" that starts from a directory containing a file named "ROOT" (the contents is not used), written
    as "//", followed by the path to the directory, using "/" as the directory separator. E.g.

    //binaries/my_binary

    Artifacts were planned to be used more frequently, but are now mainly used just for downloading and extracting
    binaries.
    See recipe.proto.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class Data(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        EXTRACTED_ARCHIVE_SET_FIELD_NUMBER: builtins.int
        @property
        def extracted_archive_set(self) -> global___ArtifactMetadataExtractedArchiveSet: ...
        def __init__(
            self,
            *,
            extracted_archive_set: global___ArtifactMetadataExtractedArchiveSet | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["data", b"data", "extracted_archive_set", b"extracted_archive_set"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["data", b"data", "extracted_archive_set", b"extracted_archive_set"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["data", b"data"]) -> typing_extensions.Literal["extracted_archive_set"] | None: ...

    DATA_FIELD_NUMBER: builtins.int
    DERIVED_FROM_FIELD_NUMBER: builtins.int
    COMMENT_FIELD_NUMBER: builtins.int
    @property
    def data(self) -> global___ArtifactMetadata.Data:
        """The artifact's type-specific data."""
    @property
    def derived_from(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """A list of artifact paths from which this artifact is derived. Typically, this is similar to
        following the input artifacts in the recipe transitively, but some artifacts may not have a
        recipe because they were created manually so it is still useful to have this field.
        """
    comment: builtins.str
    def __init__(
        self,
        *,
        data: global___ArtifactMetadata.Data | None = ...,
        derived_from: collections.abc.Iterable[builtins.str] | None = ...,
        comment: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["data", b"data"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["comment", b"comment", "data", b"data", "derived_from", b"derived_from"]) -> None: ...

global___ArtifactMetadata = ArtifactMetadata

@typing_extensions.final
class ArtifactMetadataExtractedArchiveSet(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ARCHIVE_SET_FIELD_NUMBER: builtins.int
    @property
    def archive_set(self) -> gfauto.common_pb2.ArchiveSet: ...
    def __init__(
        self,
        *,
        archive_set: gfauto.common_pb2.ArchiveSet | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["archive_set", b"archive_set"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["archive_set", b"archive_set"]) -> None: ...

global___ArtifactMetadataExtractedArchiveSet = ArtifactMetadataExtractedArchiveSet
